#!/bin/bash

# Function to display help
show_help() {
  cat << EOF
Usage: $0 [-i <INDEX_FILE_PATH>] [-n <NTH_LAST_MESSAGE>] [-c <MESSAGE_COUNT>] [-h]
Options:
  -i <INDEX_FILE_PATH>          Specify the path to the index JSON file (default: /root/artifacts/transcript-blocks.json).
  -n <NTH_LAST_MESSAGE>         Specify how many messages to go back from the last message (default: 0 i.e., the last message).
  -c <MESSAGE_COUNT>      Specify how many messages to extract (default: 1).
  --help                         Display this help message and exit.
EOF
}

INDEX_FILE_PATH="/root/artifacts/transcript-blocks.json"
NTH_LAST_MESSAGE=0
MESSAGE_COUNT=1

# Parse command line arguments
while getopts ":n:c:i:h" opt; do
  case ${opt} in
    i)
      INDEX_FILE_PATH=$OPTARG
      ;;
    n)
      NTH_LAST_MESSAGE=$OPTARG
      ;;
    c)
      MESSAGE_COUNT=$OPTARG
      ;;
    h)
      show_help
      exit 0
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      show_help
      exit 1
      ;;
  esac
done

# Call the terminal-ai-transcript-indexer script to update the index
terminal-ai-transcript-indexer --update --index-file="$INDEX_FILE_PATH"

# Check if the index file exists
if [[ ! -f "$INDEX_FILE_PATH" ]]; then
  echo "Error: Index file '$INDEX_FILE_PATH' does not exist."
  exit 1
fi

# Ensure messages are sorted by timestamp using jq.
# This simplifies operations such as:
#   - NTH_LAST_MESSAGE messages and MESSAGE_COUNT messages are able to return
#     messages for revision or expansion effectively
#   - Diffs are predictable with changes being appended to the end
messages=$(jq -c ". | reverse | .[$NTH_LAST_MESSAGE:$((NTH_LAST_MESSAGE + MESSAGE_COUNT))]" "$INDEX_FILE_PATH")

# Function to extract lines from a file
extract_lines() {
  local file=$1
  local start_line=$2
  local end_line=$3
  sed -n "${start_line},${end_line}p" "$file"
}

# Loop through the messages and extract their content from the files
echo "$messages" | jq -c '.[]' | while read -r message; do
  file=$(echo "$message" | jq -r '.file')
  start_line=$(echo "$message" | jq -r '.start_line')
  end_line=$(echo "$message" | jq -r '.end_line')
  
  extract_lines "$file" "$start_line" "$end_line"
done

# Project Meeting Minutes: Development of Git Project Manager

**Date & Time:** 2024-05-08

**Participants:**
- **ChatGPT** - Assistant
- **User** - Project Initiator

## Objective
To design and outline the Git Project Manager for the Orchestration Architect, ensuring the system is self-documenting and can auto-generate documentation and code.
```
# (@objective=OBJ-OA-GPM-001) Design and develop a self-documenting and auto-generating documentation and code system for the Git Project Manager.
```
---

## Agenda Item 1: System Design and Requirement Specification

### Discussion Points
- Discussed integrating Software Requirement Specification (SRS) codes aligned with SWEBOK to manage software requirements.
- Explored the application of category theory in software system modeling.
```
# (@theory=THEORY-OA-GPM-001) Explore category theory applications in software system modeling.
```
### Decisions Made
- Agreed to implement a structured labeling system for documentation to enhance traceability.
```
# (@decision=DEC-OA-GPM-001) Implement a structured labeling system for enhanced traceability of information.
```
### Action Items
- Develop a comprehensive labeling scheme including labels such as SRS, IDEA, TODO, and STRATEGY.
```
# (@action=ACT-OA-GPM-001) Develop a extendable labeling scheme for project documentation and communication
```
---

## Agenda Item 2: Infrastructure as Code and Security Integration

### Discussion Points
- Discussed integrating security into DevOps using Infrastructure as Code (IaC), focusing on a Domain Specific Language (DSL) similar to Cucumber.
```
# (@idea=IDEA-OA-GPM-001) Integrate security practices into DevOps using IaC.
```
### Decisions Made
- Decided to define a DSL to clearly describe infrastructure setups for automation purposes.
```
# (@decision=DEC-OA-GPM-002) Define a DSL for specification files for validation, migration and tests.
```
### Action Items
- Create initial drafts of DSL syntax and semantics for the Git Project Manager.
```
# (@action=ACT-OA-GPM-002) Draft DSL syntax and semantics grammar
``
---

## Agenda Item 3: Self-Documenting System Architecture

### Discussion Points
- Discussed making the system bootstrappable from a seed, which can regenerate the entire system or modify earlier versions to rebuild.
```
# (@strategy=STRAT-OA-GPM-001) Implement a bootstrappable system architecture.
```
### Decisions Made
- Agreed to implement a model-driven architecture to auto-generate documentation and code from system models.
```
# (@decision=DEC-OA-GPM-003) Design Architecture for auto-generating documentation and code.
```
### Action Items
- Prototype the first version of the model-driven system for the Git Project Manager.
```
# (@action=ACT-OA-GPM-003) Define requirements for Git Package Managerar
```
---

## Additional Notes
```
# (@agenda) Detail what needs to be done in relation to getting next release 
# (@agenda) Streamline conversations, capture the nuance of record keeping
```
## Approval **pending**
**Minutes Prepared By:** ChatGPT  
Steps for approval:
```
# (@STATUS=pending-approval)
# (@TODO) Write script to extract tags
#         and ensure that the fields are mapped
```
---
### Project Meeting Minutes: Enhancing Interaction and Documentation Processes with GPT

**Date & Time:**  
- 2024-05-08

**Participants:**  
- **ChatGPT** - Assistant
- **User** - Project Initiator

## Objective
To formalize the process of documenting interactions between the Project Initiator and GPT, ensuring effective usage of tags for easy navigation and retrieval, and outlining future discussions on utilizing GPT to its full potential.

# (@objective=OBJ-OA-GPM-002) Formalize GPT interaction and documentation processes with effective tagging and outline future enhancement discussions.

---

## Agenda Item: Documentation Process Enhancement

### Discussion Points
- Developed guidelines for capturing and documenting conversations between the Project Initiator and GPT using structured tags in Markdown format.
- Discussed the implementation of a tagging system to categorize and facilitate the retrieval of information.

# (@discussion=DISC-OA-GPM-001) Discuss and develop guidelines for using structured tags in GPT conversations.

### Decisions Made
- Adopted a specific set of tags to be used consistently in documenting interactions, which include @INSTRUCT, @EXPLAIN, @REVIEW, @ENHANCE, @DECISION, and @ACTION.

# (@decision=DEC-OA-GPM-002) Adopt a structured set of tags for documenting GPT interactions.

### Action Items
- Create an appendix in the project documentation that outlines the process and guidelines for capturing and documenting interactions using tags.

# (@action=ACT-OA-GPM-002) Create an appendix detailing the tagging and documentation process.

---

## Future Discussions

### Topics for Next Meeting
- Explore various roles of GPT in assisting with project management, including summarization, API calls, and scripting integrations.
- Discuss mechanisms to copy relevant content to web interfaces and manage documentation files for easy access and searchability.

# (@future=FT-OA-GPM-001) Explore expanded uses of GPT in project management and documentation processes.

### Tag Definitions and Usage
- **@INSTRUCT**: Directives given to GPT to perform specific tasks.
- **@EXPLAIN**: Requests for GPT to provide detailed explanations or clarifications.
- **@REVIEW**: Marks content that needs to be reviewed or reconsidered.
- **@ENHANCE**: Suggestions for improvements or enhancements in processes or content.
- **@DECISION**: Decisions made during interactions.
- **@ACTION**: Action items or tasks that arise during discussions.

# (@tag-definition=TAGDEF-OA-GPM-001) Define and explain the usage of various tags in the documentation.

---

## Appendix: Detailed Documentation Guidelines

### A1. Capturing and Documenting Conversations
Outlined specific procedures and tag usage for documenting interactions with GPT, ensuring clarity and retrievability.

# (@appendix=APP-OA-GPM-005) Provide guidelines for capturing and documenting GPT interactions effectively.

### Additional Notes
- Emphasized the importance of consistent tagging for future retrievability and the integration of documentation into broader project management tools.

## Approval **pending**
**Minutes Prepared By:** ChatGPT  

# @(TODO) Move tags away from GPM
---
### Requirements for the `fzf` Tag Extraction Script

Below are the detailed requirements for the script that uses `fzf` or accepts a directory path to select files and output lines that match specific tag patterns. The requirements are documented with SRS labels to facilitate traceability and management.

# Requirements for Tag Extraction Script
## Corrected requirements
```
# (@SRS=SRS-UTIL-001,UTIL=extract-tags) Non-interactive with directory or file path is provided, Use FZF otherwise
# (@SRS=SRS-UTIL-002,UTIL=extract-tags) Match lines that follow the provided pattern`# (@<content>)`
# (@SRS=SRS-UTIL-003,UTIL=extract-tags) Output fields line number, relative file path if supplied directory from supplied directory, relative file path from cwd if fzf
# (@SRS=SRS-UTIL-004,UTIL=extract-tags) Executes from Command Line Terminal, outputs to stdout
# (@SRS=SRS-UTIL-005,UTIL=extract-tags) If path or file provides, or list of files, operate in non-interactive mode by-passing `fzf`
# (@SRS=SRS-UTIL-006,UTIL=extract-tags) Use grep or silver to get lines instead of reading each line
# (@INSTRUCT) USE GREP TO GET LINES FOR PATTERN
```
## SRS-OA-UTIL-001: Directory Input Option
**Requirement:** The script must allow the user to pass a directory as an input parameter. If a directory is provided, the script should skip the `fzf` selection interface and directly process files in the specified directory.

## SRS-OA-UTIL-002: Tag Pattern Matching
**Requirement:** The script must search for lines containing tags formatted as `# (@<wildcard>)` and extract these lines.

## SRS-OA-UTIL-003: Output Format
**Requirement:** The script must output the relative file path and line number for each matching line. The user should have the option to output either the entire line containing the tag or just the contents within the parentheses.

## SRS-OA-UTIL-004: Command Line Interface
**Requirement:** The script should be executable from the terminal and output results to stdout, facilitating integration with other tools or scripts.

## SRS-OA-UTIL-005: Non-interactive Mode
**Requirement:** When a directory is specified, the script should operate in a non-interactive mode, bypassing `fzf` and directly processing the files.
# (@agenda=AGN-OA-NXT-001) Document current tools and their requirements in the next meeting.
```
```

### Script Implementation

Below is the implementation of the script based on the outlined requirements. The script is designed to be used in a Unix-like environment and assumes that `fzf` is installed if interactive mode is used.

#### FIRST ATTEMPT
```bash
#!/bin/bash

# Usage: ./tag-extractor.sh [--line] [directory]
# If a directory is given, use it; otherwise, use fzf to select files interactively.

output_line_content=false
directory="${2:-$(pwd)}"

# Check for '--line' option
if [[ "$1" == "--line" ]]; then
    output_line_content=true
elif [[ -n "$1" ]] && [[ ! "$1" =~ ^-- ]]; then
    directory="$1"
fi

# Function to process files and extract tagged lines
extract_tags() {
    local file_path="$1"
    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ \# \(\@\<(.+)\>\) ]]; then
            local tag_content="${BASH_REMATCH[1]}"
            if [[ "$output_line_content" == "true" ]]; then
                echo "$file_path:$line_number:$line"
            else
                echo "$file_path:$line_number:$tag_content"
            fi
        fi
        ((line_number++))
    done < "$file_path"
}

export -f extract_tags

# Main script execution
if [[ -d "$directory" ]]; then
    # Process all files in the directory
    find "$directory" -type f -exec bash -c 'extract_tags "$0"' {} \;
else
    # Use fzf to select files and process them
    fzf --preview 'cat {}' --preview-window=up:70% --multi | xargs -I {} bash -c 'extract_tags "$0"' {}
fi
```
#### Second Attempt
```
#!/bin/bash

# Usage: ./tag_extractor.sh [--line] [directory or file path]
# This script extracts lines containing specific tags from files, using grep for efficiency.
# It operates in non-interactive mode if a directory or file path is provided, or uses `fzf` to select files interactively.

# Check for command line options
output_line_content=false
if [[ "$1" == "--line" ]]; then
    output_line_content=true
    shift
fi

directory="$1"

# Function to extract tags using grep
extract_tags() {
    local path="$1"
    local pattern='# \(@<.*>\)'

    # Determine the output format based on user preference
    if [[ "$output_line_content" == "true" ]]; then
        grep -Hn "$pattern" "$path" | sed -E 's/:.*# \(@([^)]+)\)/:\1/'
    else
        grep -Hn "$pattern" "$path" | sed -E 's/:.*# \(@([^)]+)\).*/:\1/'
    fi
}

# Main execution block
if [[ -n "$directory" && -e "$directory" ]]; then
    # Non-interactive mode: process specified directory or file
    # (@SRS=SRS-UTIL-005,UTIL=extract-tags) Operate in non-interactive mode by-passing `fzf`
    if [[ -d "$directory" ]]; then
        # Process all files in the directory
        find "$directory" -type f -exec bash -c 'extract_tags "$0"' {} \;
    elif [[ -f "$directory" ]]; then
        # Process a single file
        extract_tags "$directory"
    fi
else
    # Interactive mode: use fzf to select files
    # (@SRS=SRS-UTIL-001,UTIL=extract-tags) Use FZF otherwise
    fzf --preview 'cat {}' --preview-window=up:70% --multi | xargs -I {} bash -c 'extract_tags "$0"' {}
fi
```

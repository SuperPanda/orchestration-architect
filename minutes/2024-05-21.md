

# Minutes 2024-05-21
# (@conversation) Conversation Record with GPT Begins
---

```
# (@speech, speaker=GPT)
```

You're right; having both `vertices` and `from_vertex`/`to_vertex` is redundant. We should streamline the design to use `from_vertex` and `to_vertex` only, as these fields are sufficient to represent the relationship.

Regarding safety, we can improve robustness by ensuring the schema drives the data class creation and usage strictly. This approach minimizes the risk associated with changes in the schema by enforcing schema validation and automatic class generation.

### Project Structure

We'll organize the project with a clear structure, including the main code, schema definition, and tests.

#### Project Layout

```
category_database/
├── schema/
│   └── graph_schema.yaml
├── src/
│   ├── __init__.py
│   ├── dataclass_factory.py
│   ├── graph_manager.py
│   ├── serialization.py
└── tests/
    ├── __init__.py
    └── test_graph_manager.py
```

### Step 1: Define the Schema

#### `schema/graph_schema.yaml`

```yaml
Graph:
  vertices:
    type: dict
    key: id
    value: 
      $ref: Vertex
  edges:
    type: dict
    key: id
    value:
      $ref: Edge

Vertex:
  id:
    type: str
  label:
    type: str
  attributes:
    type: dict
    key: str
    value: str
  in_edges:
    type: list
    item_type: str
  out_edges:
    type: list
    item_type: str

Edge:
  id:
    type: str
  from_vertex:
    type: str
  to_vertex:
    type: str
  label:
    type: str
  attributes:
    type: dict
    key: str
    value: str
  metadata:
    type: dict
    key: str
    value: str
```

### Step 2: Dataclass Factory

#### `src/dataclass_factory.py`

```python
from dataclasses import make_dataclass, field
from typing import Dict, List, Tuple, Any
import yaml

def create_dataclass_from_schema(name: str, schema: Dict[str, Any]):
    fields = []
    for field_name, field_info in schema.items():
        field_type = field_info["type"]
        if field_type == "str":
            fields.append((field_name, str, field(default_factory=str)))
        elif field_type == "dict":
            fields.append((field_name, Dict[str, str], field(default_factory=dict)))
        elif field_type == "list":
            fields.append((field_name, List[str], field(default_factory=list)))
        elif field_type == "tuple":
            fields.append((field_name, Tuple[str, str], field(default_factory=tuple)))
        else:
            raise ValueError(f"Unsupported field type: {field_type}")
    return make_dataclass(name, fields)

def load_schema(schema_path: str) -> Dict[str, Any]:
    with open(schema_path, 'r') as file:
        return yaml.safe_load(file)
```

### Step 3: Serialization and Deserialization

#### `src/serialization.py`

```python
from dataclasses import asdict, is_dataclass
from typing import Any, Type

def serialize_dataclass(obj: Any) -> Any:
    if is_dataclass(obj):
        return asdict(obj)
    if isinstance(obj, list):
        return [serialize_dataclass(item) for item in obj]
    if isinstance(obj, dict):
        return {key: serialize_dataclass(value) for key, value in obj.items()}
    return obj

def deserialize_dataclass(data: Any, cls: Type) -> Any:
    if isinstance(data, dict):
        fieldtypes = {f.name: f.type for f in cls.__dataclass_fields__.values()}
        return cls(**{f: deserialize_dataclass(data[f], fieldtypes[f]) for f in data})
    elif isinstance(data, list):
        return [deserialize_dataclass(item, cls.__args__[0]) for item in data]
    else:
        return data
```

### Step 4: Graph Management

#### `src/graph_manager.py`

```python
import os
import uuid
import yaml
from dataclass_factory import create_dataclass_from_schema, load_schema
from serialization import serialize_dataclass, deserialize_dataclass

schema = load_schema('../schema/graph_schema.yaml')

Vertex = create_dataclass_from_schema("Vertex", schema["Vertex"])
Edge = create_dataclass_from_schema("Edge", schema["Edge"])
Graph = create_dataclass_from_schema("Graph", schema["Graph"])

class GraphManager:
    def __init__(self, filepath: str):
        self.filepath = filepath
        self.graph = Graph(vertices={}, edges={})
        if os.path.exists(filepath):
            self.load_graph()

    def add_vertex(self, label: str, attributes: Dict[str, str] = None) -> Vertex:
        vertex = Vertex(id=str(uuid.uuid4()), label=label, attributes=attributes or {})
        self.graph.vertices[vertex.id] = vertex
        self.save_graph()
        return vertex

    def remove_vertex(self, vertex_id: str):
        if vertex_id not in self.graph.vertices:
            print(f"Vertex {vertex_id} not found.")
            return
        # Remove associated edges
        for edge_id in self.graph.vertices[vertex_id].in_edges + self.graph.vertices[vertex_id].out_edges:
            self.remove_edge(edge_id)
        del self.graph.vertices[vertex_id]
        self.save_graph()

    def add_edge(self, from_vertex_id: str, to_vertex_id: str, label: str = "", attributes: Dict[str, str] = None, metadata: Dict[str, str] = None) -> Edge:
        if from_vertex_id not in self.graph.vertices or to_vertex_id not in self.graph.vertices:
            print(f"Both vertices must exist to create an edge.")
            return
        edge = Edge(
            id=str(uuid.uuid4()),
            from_vertex=from_vertex_id,
            to_vertex=to_vertex_id,
            label=label,
            attributes=attributes or {},
            metadata=metadata or {}
        )
        self.graph.edges[edge.id] = edge
        self.graph.vertices[from_vertex_id].out_edges.append(edge.id)
        self.graph.vertices[to_vertex_id].in_edges.append(edge.id)
        self.save_graph()
        return edge

    def remove_edge(self, edge_id: str):
        if edge_id not in self.graph.edges:
            print(f"Edge {edge_id} not found.")
            return
        edge = self.graph.edges.pop(edge_id)
        from_vertex_id, to_vertex_id = edge.from_vertex, edge.to_vertex
        if edge_id in self.graph.vertices[from_vertex_id].out_edges:
            self.graph.vertices[from_vertex_id].out_edges.remove(edge_id)
        if edge_id in self.graph.vertices[to_vertex_id].in_edges:
            self.graph.vertices[to_vertex_id].in_edges.remove(edge_id)
        self.save_graph()

    def display_graph(self):
        for vertex in self.graph.vertices.values():
            print(f"Vertex {vertex.id}: {vertex.label}, Attributes: {vertex.attributes}, Inbound Edges: {vertex.in_edges}, Outbound Edges: {vertex.out_edges}")
        for edge in self.graph.edges.values():
            print(f"Edge {edge.id}: {edge.label}, From: {edge.from_vertex}, To: {edge.to_vertex}, Attributes: {edge.attributes}, Metadata: {edge.metadata}")

    def save_graph(self):
        with open(self.filepath, 'w') as file:
            yaml.dump({
                "vertices": {vertex.id: serialize_dataclass(vertex) for vertex in self.graph.vertices.values()},
                "edges": {edge.id: serialize_dataclass(edge) for edge in self.graph.edges.values()}
            }, file)

    def load_graph(self):
        with open(self.filepath, 'r') as file:
            data = yaml.safe_load(file)
            self.graph.vertices = {vertex_id: deserialize_dataclass(vertex_data, Vertex) for vertex_id, vertex_data in data["vertices"].items()}
            self.graph.edges = {edge_id: deserialize_dataclass(edge_data, Edge) for edge_id, edge_data in data["edges"].items()}

# Example usage
if __name__ == "__main__":
    graph_manager = GraphManager("../data/graph.yaml")

    # Adding vertices
    vertex1 = graph_manager.add_vertex("User", {"name": "Alice"})
    vertex2 = graph_manager.add_vertex("User", {"name": "Bob"})

    # Adding an edge
    edge = graph_manager.add_edge(vertex1.id, vertex2.id, label="friend", metadata={"type": "bidirectional"})

    # Display graph
    graph_manager.display_graph()

    # Remove edge
    graph_manager.remove_edge(edge.id)

    # Remove vertex
    graph_manager.remove_vertex(vertex1.id)

    # Display graph
    graph_manager.display_graph()
```

### Step 5: Unit Tests

#### `tests/test_graph_manager.py`

```python
import unittest
from src.graph_manager import GraphManager
import os

class TestGraphManager(unittest.TestCase):

    def setUp(self):
        self.filepath = "test_graph.yaml"
        self.graph_manager = GraphManager(self.filepath)

    def tearDown(self):
        if os.path.exists(self.filepath):
            os.remove(self.filepath)

    def test_add_vertex(self):
        vertex = self.graph_manager.add_vertex("User", {"name": "Alice"})
        self.assertIn(vertex.id, self.graph_manager.graph.vertices)
        self.assertEqual(self.graph_manager.graph.vertices[vertex.id].label, "User")
        self.assertEqual(self.graph_manager.graph.vertices[vertex.id].attributes["name"], "Alice")

    def test_remove_vertex(self):
        vertex =

 self.graph_manager.add_vertex("User", {"name": "Alice"})
        self.graph_manager.remove_vertex(vertex.id)
        self.assertNotIn(vertex.id, self.graph_manager.graph.vertices)

    def test_add_edge(self):
        vertex1 = self.graph_manager.add_vertex("User", {"name": "Alice"})
        vertex2 = self.graph_manager.add_vertex("User", {"name": "Bob"})
        edge = self.graph_manager.add_edge(vertex1.id, vertex2.id, label="friend")
        self.assertIn(edge.id, self.graph_manager.graph.edges)
        self.assertIn(edge.id, self.graph_manager.graph.vertices[vertex1.id].out_edges)
        self.assertIn(edge.id, self.graph_manager.graph.vertices[vertex2.id].in_edges)

    def test_remove_edge(self):
        vertex1 = self.graph_manager.add_vertex("User", {"name": "Alice"})
        vertex2 = self.graph_manager.add_vertex("User", {"name": "Bob"})
        edge = self.graph_manager.add_edge(vertex1.id, vertex2.id, label="friend")
        self.graph_manager.remove_edge(edge.id)
        self.assertNotIn(edge.id, self.graph_manager.graph.edges)
        self.assertNotIn(edge.id, self.graph_manager.graph.vertices[vertex1.id].out_edges)
        self.assertNotIn(edge.id, self.graph_manager.graph.vertices[vertex2.id].in_edges)

if __name__ == '__main__':
    unittest.main()
```

### Conclusion

This project structure dynamically constructs dataclasses from a YAML schema and uses them to manage a graph database. The script includes functions to add and remove vertices and edges, display the graph, and persist it to a YAML file. Unit tests ensure the integrity of these operations. This setup provides a robust framework for managing category databases and understanding their underlying structure and relationships.
---

```
# (@speech, speaker=User)
```


# Terminal AI Notes
## Reactive Store
### Concepts
1. Store is the central state of the different components
2. Stores consist of:
    - Reducers: Takes an Action and supplied objects
                and updates the store
    - Actions: The operations that can be dispatched to
                the store
    - Selectors: Slices that store to only listen to regions of the state
                  that are relevant.
                 Also used to compose different pure functions that
                  allow for eassy modification and maintainence
                 Provides Memoisation via builtin LRU.
    - Action Stream: In bound stream of actions
    - State Change Stream: Stream that reports the action taken,
                            and the before and after state.
## UI
### Concepts
1. NCurses is to take a stream of (y,x, text) that will allow for efficient direct redraws
2. The components from the store will generate a mask and using the offset and dimensions of the
     component
3. The maxyz size will dispatch resize actions to the store
4. The stream will be composed from streams that memoise common operations to generate the update stream.
5. The masks will be overlaid with a mask of the available view port, allowing for components to exist
   in a space that won't cause side effects based on the view port.
6. Clearing the screen will be avoid (unless a refresh is called (need a saga to modify the selector to compute entire update)
7. Components mask should be composed in a way that the region that has been modified can easily trigger related components - idea: store values such that each bit represents a different component. and if the view
naask in the update region has a cell where the highest bit changed, use the memoised operations for the components, to use the offset, and highest bit position, to index to character being updated ( will need define limit and colimits for ensuring proper boundary checking).
8. Functors are used to convert different categories or objects into a text representation, that uses natural transformation to be able to change its representation based on context.


### Output
1. The system must always persist the state as it changes.
2. The system must resume to the exact position when reloaded.
3. The system shall support various schemas based on a specification document.

### Input
1. The keybinds are able to be set to particular actions.
2. Those actions can change.
3. The system keeps a cursor index, that points to elements in the store
4. The structure of navigation like a mindmap to determine whether to go to child or sibling,
    or a anscestors sibling if the parent has no siblings and you press to go down, is achieved
    by applying a topological sort, a depth first or breadth first depending on direction.

### Animations, Motion and ASCII Physics
Vectors, Parameteric Equations and good old linear algebra (even quarternions if crazy), using functors and
morphisms, etc. we will use the demo from the category store, to generate vector graphics in the terminal
and animations of the ascii vector graphs.

## Mindmap
### Concepts
A mind map that takes any item, and make it representable in the 


# Other things I got to fill in
## Schema, Serializationand Deserialization
### Concepts
Serialisation and Deserialsation is govern by schema specifications.
The code is not to assume any structure of the provide specifications.


## Objects
Graph
Text
Files
Program STDOUTs
...

### Concepts
## Abstract Compositional Toplogy
## Knowledge and Language Tools Integration
##  - integrate git tooling to display content
##  - Link to tagging system
##  - Link the meta document system which identifies tags
##    and allows via the tooling to adjust the scope of the tag
##    which allows automatic embedding and change detection in the 
##    generated documentation
##  - Apply the ACT used to work on files, to do layouts and 
##       to interface with the system





---

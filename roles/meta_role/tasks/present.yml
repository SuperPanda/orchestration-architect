# role: meta_role
# file: roles/meta_role/tasks/present.yml
# version: 0.5
---

### 02_Managed_Region_Before_Content ORCHESTRATION ARCHITECT REGION ###

### 03_Content_Region ORCHESTRATION ARCHITECT REGION ###
- name: Initialize meta_role_context
  ansible.builtin.set_facts:
    meta_role_context:
      specification: "{{ 'specification' | extract(meta_role_params) }}"
      metadata: "{{ 'metadata' | extract(meta_role_params) }}"
      files_list: "{{ 'specification' | extract(meta_role_params, morekeys=['files']) }}"
      directories_list: "{{ 'specification' | extract(meta_role_params, morekeys=['directories']) }}"
    plugins_context:
      update_rendered_section: "{{ [base_path, 'plugins/scripts/update_rendered_section.sh'] | path_join }}"


- name: Assert the role information exists in specifications
  ansible.builtin.assert:
    that:
      - meta_role_context.specification | default(false, true)
      - meta_role_context.metadata | default(false, true)
      - meta_role_context.specification.role_name | default(false, true)
      - meta_role_context.specification.role_path | default(false, true)
    fail_msg: |
      "Meta expects the following arguments: metadata, role_name, role_path and specification"
    success_msg: |
      Role Information Found for: '{{ meta_role_context.specification.role_name }}'

- name: Ensure Role Provided In Specification Exists
  vars:
    role_info:
      name: "{{ 'specification' | extract(meta_role_context, morekeys=['role_name']) }}"
      path: "{{ 'specification' | extract(meta_role_context, morekeys=['role_path']) }}"
      template_path: "{{ 'metadata' | extract(meta_role_context, morekeys=['role_template_path']) }}"
      default_sections: "{{ 'metadata_context' | extract(meta_role_context, morekeys=['defaults_sections']) }}"
  block:
    - name: Create Directories Listed in the Role Specification
      loop: "{{ 'directories_list' | extract(meta_role_context) }}"
      loop_control:
        loop_var: directory_item
      vars:
        directory_path: "{{ 'path' | extract(directory_item) }}"
      ansible.builtin.file:
        state: directory
        path: "{{ [base_path, role_info.template_path, directory_path] | path_join }}"
        mode: "{{ directory_mode }}"

    - name: Render files from templates specified or missing
      loop: "{{ 'files_list' | extract(meta_role_context) }}"
      loop_control:
        loop_var: file_item
      vars:
        template_variables:
          metadata: "{{ 'metadata' | extract(meta_role_context) }}"
          specification: "{{ 'specification' | extract(meta_role_context) }}"
          file: "{{ file_item }}"
      ansible.builtin.template:
        src: "{{ [base_path, role_info.template_path, file_item.template] | path_join }}"
        dest: "{{ [base_path, role_info.path, file_item.path] | path_join }}"
        mode: "{{ file_item.mode | default(file_mode) }}"
        force: '{{ file_item.state is defined and file_item.state == "pristine" }}'
      when: file_item.template is defined

    - name: Apply touch operation on files with state touch
      loop: "{{ 'files_list' | extract(meta_role_context) }}"
      loop_control:
        loop_var: file_item
      ansible.builtin.file:
        path: "{{ [base_path, role_info.path, file_item.path] | path_join }}"
        state: touch
        mode: "{{ file_item.mode | default(file_mode) }}"
      when:
        - file_item is defined
        - file_item.state == 'touch'

    - name: Apply remove operation on files with state absent
      loop: "{{ 'files_list' | extract(meta_role_context) }}"
      loop_control:
        loop_var: file_item
      ansible.builtin.file:
        path: "{{ [base_path, role_info.path, file_item.path] | path_join }}"
        state: absent
      when:
        - file_item.state is defined
        - file_item.state == 'absent'

    - name: Update fragments on files with state updated
      loop: "{{ 'files_list' | extract(meta_role_context) }}"
      loop_control:
        loop_var: file_item
      when:
        - file_item.state is defined
        - file_item.state == 'updated'
      vars:
        file_metadata: "{{ 'metadata' | extract(file_item) | default({}) }}"
        sections: "{{ 'section' | extract(file_metadata) | default(role_info.defaults_sections) }}"
        meta_role_context_delta:
          section_update_queue: >-
            {{
               sections
               | product([file_item])
               | map('zip', ['section', 'file_item'])
               | map('map', 'reverse')
               | map('community.general.dict')
            }}
      ansible.builtin.set_fact:
        meta_role_context: "{{ meta_role_context | combine(meta_role_context_delta, recursive=True, list_merge='append_rp') }}"

    - name: Create Temporary Build Directory to Build Reference File with Updated Sections
      when: "'section_update_queue' in meta_role_context"
      ansible.builtin.tempfile:
        state: directory
        prefix: orchestration_architect_workdir_
        suffix: _role_update
      register: work_directory
    - name: Ensure Directories Exist for Temporary Build Directory
      when: "'section_update_queue' in meta_role_context"
      vars:
        work_directory_paths: >-
          {{
            [[ work_directory, role_info.path ]]
            | product(
                'section_update_queue'
                | extract(meta_role_context)
                | map(attribute='file_item.path')
              )
            | map('flatten')
            | map('ansible.builtin.path_join')
            | map('ansible.builtin.dirname')
            | unique
          }}
      block:
        - name: Create Build Directories to Render Pristine Reference Files
          loop: "{{ work_directory_paths }}"
          ansible.builtin.file:
            state: directory
            mode: "{{ directory_mode }}"
            path: "{{ reference_build_path }}"
        - name: Display Update Target
          ansible.builtin.debug:
            msg: "Processing section updates for {{ role_info.name }} in {{ work_directory }}"
        - name: Render Reference Files
          loop: "{{ 'section_update_queue' | extract(meta_role_context) | map(attribute='file_item') | unique }}"
          loop_control:
            loop_var: file_item
          vars:
            template_variables:
              metadata: "{{ 'metadata' | extract(meta_role_context) }}"
              specification: "{{ 'specification' | extract(meta_role_context) }}"
              file: "{{ file_item }}"
          ansible.builtin.template:
            src: "{{ [base_path, role_info.template_path, file_item.template] | path_join }}"
            dest: "{{ [work_directory, role_info.path, file_item.path] | path_join }}"
            mode: "{{ file_item.mode | default(file_mode) }}"
        - name: Process Section Update Queue
          loop: "{{ 'section_update_queue' | extract(meta_role_context) }}"
          loop_control:
            loop_var: section_update_item
          vars:
            file_item: "{{ 'file_item' | extract(section_update_item) }}"
            section_name: "{{ 'section' | extract(section_update_item) }}"
            reference_file: "{{ [work_directory, role_info.path, file_item.path] | path_join }}"
            file_to_update: "{{ [base_path, role_info.path, file_item.path] | path_join }}"
          ansible.builtin.command: "{{ 'update_rendered_section' | plugins_context }} {{ file_to_update }} {{ reference_file }} {{ section_name }}"
          register: update_section_result
          changed_when: "'Section updated successfully' in update_section_result.stdout"
          failed_when: "'Error:' in update_section_result.stderr or update_section_result.rc != 0"

        - name: Remove Temporary Build Directory
          ansible.builtin.file:
            state: absent
            path: "{{ work_directory }}"

### 04_Managed_Region_After_Content ORCHESTRATION ARCHITECT REGION ###

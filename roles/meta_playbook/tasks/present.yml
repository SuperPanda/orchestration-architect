# role: meta_playbook
# file: roles/meta_playbook/tasks/present.yml
# version: 0.8.1
---
### 02_Managed_Region_Before_Content ORCHESTRATION ARCHITECT REGION ###

# BEGIN ORCHESTRATION ARCHITECT MANAGED BLOCK 30_managed_block_before_content
# END ORCHESTRATION ARCHITECT MANAGED BLOCK 30_managed_block_before_content

### 03_Content_Region ORCHESTRATION ARCHITECT REGION ###


# BEGIN ORCHESTRATION ARCHITECT MANAGED BLOCK 50_content_region_message
# NOTE: Manual changes should occur in this region, below the managed block
# END ORCHESTRATION ARCHITECT MANAGED BLOCK 50_content_region_message

- name: Mapping Playbook Specification to Playbook Template Variables
  ansible.builtin.set_fact:
    meta_playbook_context:
      playbook_templates_path: 'roles/meta_playbook/templates'
      specification: "{{ 'specification' | extract(meta_playbook_params) }}"
      collection_metadata: "{{ 'collection_metadata' | extract(meta_playbook_params) }}"
      metadata: "{{ 'metadata' | extract(meta_playbook_params) }}"
      state: "{{ 'specification' | extract(meta_playbook_params, morekeys=['state']) | default('present') }}"
      # From meta_playbook params (defined in roles specifications)
      # Base specification from playbook specifications adds sections and playbook_vars_files
      # Use template path from specification or collection
    plugins_context:
      update_rendered_section: "{{ [base_path, 'plugins/scripts/update_rendered_section.sh'] | path_join }}"

- name: Debug
  block:
    - name: Display Loaded Context
      ansible.builtin.debug:
        msg: |
          base_path: {{ base_path }}
          meta_playbook_context: {{ meta_playbook_context }}
          plugins_context: {{ plugins_context }}
    - name: Debug collection_info
      ansible.builtin.debug:
        msg: |
          collection_info:
            name: "{{ 'collection_metadata' | extract(meta_playbook_context, morekeys=['collection_name']) }}"
            path: "{{ 'collection_metadata' | extract(meta_playbook_context, morekeys=['path']) }}"
            template_path: "{{ 'collection_metadata' | extract(meta_playbook_context, morekeys=['template_path']) }}"
            description: "{{ 'collection_metadata' | extract(meta_playbook_context, morekeys=['description']) }}"
            sections: "{{ 'collection_metadata' | extract(meta_playbook_context, morekeys=['sections']) | default([], true) }}"

- name: Playbook 'Present' Morphism
  vars:
    playbook_templates_path: "{{ 'playbook_templates_path' | extract(meta_playbook_context) }}"
    collection_info:
      name: "{{ 'collection_metadata' | extract(meta_playbook_context, morekeys=['collection_name']) }}"
      path: "{{ 'collection_metadata' | extract(meta_playbook_context, morekeys=['path']) }}"
      template_path: "{{ [playbook_templates_path, 'collection_metadata' | extract(meta_playbook_context, morekeys=['template_path'])] | path_join}}"
      description: "{{ 'collection_metadata' | extract(meta_playbook_context, morekeys=['description']) }}"
      sections: "{{ 'collection_metadata' | extract(meta_playbook_context, morekeys=['sections']) | default([], true) }}"
    playbook_info:
      name: "{{ 'specification' | extract(meta_playbook_context, morekeys=['playbook_name']) }}"
      description: "{{ 'specification' | extract(meta_playbook_context, morekeys=['playbook_description']) | default('',true) }}"
      metadata: "{{ 'specification' | extract(meta_playbook_context, morekeys=['metadata']) | default({}, true) }}"
      # combine the collection and playbook path
      path: "{{ [collection_info.path, 'specification' | extract(meta_playbook_context, morekeys=['playbook_path'])] | path_join }}"
      # Defaults to using collection default template if not specified
      template_path: "{{ 'specification' | extract(meta_playbook_context, morekeys=['template_path']) | default(collection_info.template_path, true) }}"
      # Sections that are modified when updated
      # In the playbook specification, the default sections
      #   are found in the 'Base' object.
      # Playbook specifications containing a 'sections' object,
      #    will be appended to the default list for that playbook.
      sections: "{{ 'specification' | extract(meta_playbook_params, morekeys=['sections']) }}"
    # Variables used by playbook templates.
    # Templates Variables are taken from this object and supplied to template
    # in 'roles/meta_playbook/templates/fragments/10_template_vars.j2
    template_variables:
      metadata: "{{ 'metadata' | extract(meta_playbook_context) }}"
      collection_name: "{{ collection_info.name }}"
      specification: "{{ 'specification' | extract(meta_playbook_context) }}"
      playbook_name: "{{ playbook_info.name }}"
      playbook_path: "{{ playbook_info.path }}"
      playbook_metadata: "{{ playbook_info.metadata }}"
    meta_playbook_context_delta:
      playbook_sections: "{{ [collection_info.sections, playbook_info.sections] | flatten | unique }}"
      playbook_name: "{{ playbook_info.name }}"
      playbook_path: "{{ [base_path, playbook_info.path] | path_join }}"
      template_path: "{{ [base_path, playbook_info.template_path] | path_join }}"
  block:
    - name: Enrich context required for specification processing
      ansible.builtin.set_fact:
        meta_playbook_context: "{{ meta_playbook_context | combine(meta_playbook_context_delta, recursive=True, list_merge='append_rp') }}"
    - name: Debug meta_playbook_context
      debug:
        var: meta_playbook_context
    - name: Assert the specifications are correctly defined needed to supply templates or processing
      ansible.builtin.assert:
        that:
          - base_path | default(false, true)
          - collection_info | default(false, true)
          - playbook_info | default(false, true)
          - template_variables | default(false, true)
          - plugins_context | default(false, true)
        fail_msg: |
          An error has occurred. Check meta_playbook present.yml task file for list of possible issues.
    - name: Validate and create directory if it does not exist
      vars:
        playbook_directory_path: "{{ 'playbook_path' | extract(meta_playbook_context) | dirname }}"
      ansible.builtin.file:
        state: directory
        path: "{{ playbook_directory_path }}"
        mode: "{{ directory_mode }}"
    - name: Display Template Variables
      debug:
        var: template_variables
    - name: Ensure playbooks exist and regenerated if specified
      vars:
        playbook_template_path: "{{ 'template_path' | extract(meta_playbook_context) }}"
        playbook_file_path: "{{ 'playbook_path' | extract(meta_playbook_context) }}"
        specification: "{{ 'specification' | extract(meta_playbook_context) }}"
        playbook_state: "{{ 'state' | extract(meta_playbook_context) }}"
      ansible.builtin.template:
        src: "{{ playbook_template_path }}"
        dest: "{{ playbook_file_path  }}"
        mode: "{{ specification.file_mode | default(file_mode, true) }}"
        force: '{{ playbook_state is defined and playbook_state == "pristine" }}'
      register: processed_playbook_info
    - name: Generate pristine playbook from latest template to update specified user-edited files
      vars:
        playbook_already_processed: "{{ processed_playbook_info.changed | default(false, true) }}"
        specification: "{{ 'specification' | extract(meta_playbook_context) }}"
        playbook_configured_for_updates: "{{ specification.state is defined and specification.state == 'updated' }}"
      when:
        - not playbook_already_processed
        - playbook_configured_for_updates
      block:
        - name: Create Temporary File to Render Reference Pristine Playbook
          ansible.builtin.tempfile:
            state: file
            suffix: '.tmp.pristine'
          register: temp_file
        - name: Render Template into Temporary Reference File
          vars:
            template_path: "{{ 'template_path' | extract(meta_playbook_context) }}"
            render_target: "{{ temp_file.path }}"
            specification: "{{ 'specification' | extract(meta_playbook_context) }}"
          ansible.builtin.template:
            src: "{{ template_path }}"
            dest: "{{ render_target }}"
            mode: "{{ specification.file_mode | default(file_mode, true) }}"
          changed_when: false
        - name: Replace specified sections from Reference to Playbook
          vars:
            section_update_script: "{{ 'update_rendered_section' | extract(plugins_context) }}"
            file_to_update: "{{ 'playbook_path' | extract(meta_playbook_context) }}"
            rendered_template: "{{ temp_file.path }}"
          loop: "{{ 'playbook_sections' | extract(meta_playbook_context) }}"
          loop_control:
            loop_var: section_name
          ansible.builtin.command: "{{ section_update_script }} {{ file_to_update }} {{ rendered_template }} {{ section_name }}"
          register: update_section_result
          changed_when: "'Section updated successfully' in update_section_result.stdout"
          failed_when: "'Error:' in update_section_result.stderr or update_section_result.rc != 0"
        - name: Remove Temporary Reference File
          ansible.builtin.file:
            state: absent
            path: "{{ temp_file.path }}"


### 04_Managed_Region_After_Content ORCHESTRATION ARCHITECT REGION ###

# BEGIN ORCHESTRATION ARCHITECT MANAGED BLOCK 90_managed_block_after_content
# END ORCHESTRATION ARCHITECT MANAGED BLOCK 90_managed_block_after_content

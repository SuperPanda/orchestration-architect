# file: vars/specifications/0.8.1/playbooks.yml
---
orchestration_role: &orchestration_role
  name: "meta_orchestrator"
  state: present
  specifications_version: "0.8.1"
  specifications_path: "vars/specifications"
  scope: schema

play_params: &default_params
  hosts: localhost
  connection: local

playbooks_specifications:
  # Start Metadata
  metadata:
    non_collection_keys: ['Base', 'metadata']
    collections:
      Meta:
        collection_name: Meta
        path: playbooks/Meta
        template_path: playbooks/meta.yml.j2
        description: |
          A collection of playbooks build, modify and extend Orchestration
          Architect, ensuring that the design of the system is consistent, managable,
          adheres to the underlying design principles and ensures compatability with
          different components and dynamically updating the interactions between components
          when designs change. Manages specifications, migrations, playbooks and roles.
      OA000_Recovery:
        collection_name: OA000_Recovery
        path: playbooks/OA000_Recovery
        template_path: playbooks/base.yml.j2
        description: |
          Contains the recovery system required to recover the live system.
      OA001_LiveUSB:
        collection_name: OA001_LiveUSB
        path: playbooks/OA001_LiveUSB
        template_path: playbooks/base.yml.j2
        description: |
          Contains playbooks to configure startup operations, customize
          the system, create snapshots and remote backups. Update subvolume or bind
          mounts, add/remove service accounts. It also includes the generation of the
          image fora live operating system of OA002_Hypervisor and deployment over PXE,
          which has a default auto login guest account, desktop environment, with baked
          SSH access for the OA001 root user and OA001_service worker, to allow instant
          access to deployed system.
      OA002_Hypervisor:
        collection_name: OA002_Hypervisor
        path: playbooks/OA002_Hypervisor
        template_path: playbooks/base.yml.j2
        description: |
          Playbooks to remotely manage a bare metal nested hypervisor. Allows
          for instant reconfiguration from fresh boot of the live environment booted
          from the PXE service, and configuration of a running system that is persisted
          due to configuration running from playbook. Connects via SSH using credentials
          baked in.
      Sandbox:
        collection_name: Sandbox
        path: playbooks/Sandbox
        template_path: playbooks/base.yml.j2
        description: |
          Experiments and prototypes.
      OA999_Test:
        collection_name: OA999_Test
        path: playbooks/OA999_Test
        template_path: playbooks/base.yml.j2
        description: |
          Test LiveUSB Deployment to seperate device. Currently being used to
          design the ability to create a way to generate templates to create playbooks
          for LiveUSB systems, and to identify blocks of composable configuration variant
          blocks.
      Default:
        collection_name: Default
        path: playbooks/Default
        template_path: playbooks/base.yml.j2
        description: Playbooks not in a collection.
  Base:
    playbook_vars_files:
      - ../../vars/environment.yml
    sections:
      - 20_file_header
      - 30_managed_block_before_content
      - 50_content_region_message
      - 90_managed_block_after_content
  Sandbox:
    Ephemeral_Runner:
      playbook_name: Ephemeral Runner
      playbook_description: Run in Container
      playbook_path: Ephemeral_Runner.yml
      state: updated
      metadata:
        pre_run_playbooks:
          - "../Meta/Setup_Environment.yml"
      
    Temporary Container Experiment:
      playbook_name: Temporary Container Experiment
      playbook_description: |
        ===========================================
        Experiment - Temporary Container Experiment
        ===========================================

        ---------------------------
        INSTRUCTIONS TO TERMINAL AI
        ---------------------------
        REVIEW THIS SECTION AND NIT PICK THE DESIGN.
        WE ARE WORKSHOPPING SOME STANDARDISED PLAYBOOK
        IN-LINE DOCUMENTATION.

        Usage
        -----
        Triggers the Meta Orchestrator system to apply configurations
        defined in the specification files. The other versions can be
        referenced by adding
        '-e meta_orchestrator_specifications_version=<version>'.

        Scope
        -----
          Expand the category to allow instantiation
        using device mapper to generate a deterministic
        name for the loop device, adhereing to the
        idiopotency requirement.

        Requirements
        ------------
          - Setup Storage Pool Target with Storage Role
          - Setup Volume Pool in a loop device
            targetting a block device image,
            defined by the `storage_loop_device_target` var
          - the following should generate `<BLOCK_DEVICE_IMAGE_PATH>` file (if it does not already).
            ```yaml            
            role:
              name: storage
              storage:
                loop_device:
                  name: <LOOP_DEVICE_NAME>
                  target: <LOOP_DEVICE_TARGET>
            ```
          - Create a role `orchestration_architect.Storage.loop_device`:
            ```
            `*<LOOP_DEVICE_STATE>*`: present | absent | info | offline | online
            ```
          - Ensure `storage` adds functor structure details for `loop_device` role
          - Deploy a mount a btrfs subvolume in the ephemeral storage pool in `tmpfs` (ram) in `nspawn`.
          - Take advantage of `copy-on-write` mechanisms,
            to design composable overlays with `btrfs_subvolumes`
      playbook_path: Temporary_Container_Experiment.yml
      state: updated
      metadata:
        pre_run_playbooks:
          - "../Meta/Setup_Environment.yml"
  OA999_Test:
    Prepare_OA999:
      playbook_name: Prepare OA999 Demo
      playbook_path: Prepare_OA999.yml
      playbook_description: |
        Creates a Keystore to hold keys to repeatedly access LUKS containers
          during provisioning allowing for experimentation and building features.
        Configures Installation Target Device.
        Will need to set keystore to use luks, and be a separate role,
          which will use later to be built roles zram_device and virtual_block_device
      state: updated
      metadata:
        pre_run_playbooks:
          - "../Meta/Setup_Environment.yml"
    Build_OA999:
      playbook_name: Build OA999
      playbook_path: Build_OA999.yml
      playbook_description: |
        Opens Keystore if unable to find development key.
        Provisions a device. Need to move keyfile path to be in enrolment.yml,
        and setup the vault to close after playbook is complete or if it fails.
        And need to make it have password be reset, and when the provision keyfile
        is removed, a new keyfile should be generated to replace the old one but stored
        on the device in the keystore.
      state: updated
      metadata:
        pre_run_playbooks:
          - "../Meta/Setup_Environment.yml"
    Deactivate_OA999:
      playbook_name: Prepare OA999 for Ejection
      playbook_path: Deactivate_OA999.yml
      playbook_description: |
        Removes mounts, closes LUKS containers and configures the system to be used elsewhere.
      metadata:
        pre_run_playbooks:
          - "../Meta/Setup_Environment.yml"
  OA001_LiveUSB:
    Provision:
      playbook_name: Provision OA001 LiveUSB System
      playbook_path: OA001_Provision.yml
      playbook_description: Provisions the Master System as Bootable Encrypted LiveUSB.
      state: updated
      metadata:
        pre_run_playbooks:
          - Setup_Environment.yml
        post_run_playbooks:
          - Provision/Activate.yml
          - Provision/Build.yml
          - Provision/Deactivate.yml
    Provision_Activate:
      playbook_name: Prepare OA001 LiveUSB Device for Modification
      playbook_path: OA001_Provision/Activate.yml
      state: updated
    Provision_Build:
      playbook_name: Build and/or Repair OA001 LiveUSB System
      playbook_path: OA001_Provision/Build.yml
      state: updated
    Provision_Deactivate:
      playbook_name: Prepare OA001 LiveUSB Device for Ejection
      playbook_path: OA001_Provision/Deactivate.yml
      state: updated




  Meta:
    Generate_Playbooks:
      playbook_name: Generate Playbooks From Specifications
      playbook_path: Generate_Playbooks.yml
      playbook_description: |
        Reads the playbook specification and runs the orchestration process to
        generate, update or remove playbooks.
      state: pristine
      metadata:
        auto_generated: true
        pre_run_playbooks:
          - Setup_Environment.yml
      playbook_content:
        - play_id: Generate Playbooks
          <<: *default_params
          tasks:
            - name: Trigger Orchestration of Playbooks
              trigger_role:
                <<: *orchestration_role
                state: present
                operations: ['process_playbooks']
                scope: all

    Generate_Templates:
      playbook_name: Generate Templates From Specifications
      playbook_path: Generate_Templates.yml
      state: pristine
      metadata:
        auto_generated: true
        pre_run_playbooks:
          - Setup_Environment.yml
      playbook_content:
        - play_id: Generate Templates
          <<: *default_params
          tasks:
            - name: Trigger Orchestration of Templates
              trigger_role:
                <<: *orchestration_role
                state: present
                operations: ['process_templates']
                schema:
                  templates:
                    Roles: {}
                    Playbooks: {}

    Generate_Roles:
      playbook_name: Generate Roles From Specifications
      playbook_path: Generate_Roles.yml
      playbook_description: |
        Builds Roles from Specifications.
      state: pristine
      metadata:
        auto_generated: true
        pre_run_playbooks:
          - Setup_Environment.yml
      playbook_content:
        - play_id: Generate Roles
          <<: *default_params
          tasks:
            - name: Trigger Orchestration of Roles
              trigger_role:
                <<: *orchestration_role
                state: present
                operations: ['process_roles']
                schema:
                  roles:
                    Storage: {}


    Trigger_Bootstrap:
      playbook_name: Setup and Trigger Bootstrap Build from Seed
      playbook_path: Trigger_Bootstrap.yml
      state: present
    Bootstrap_Workspace:
      playbook_name: Bootstrap Current Workspace from Seed to Pristine Environment
      playbook_path: Bootstrap_Workspace.yml
      state: present

    Setup_Environment:
      playbook_name: Setup Environment
      playbook_path: Setup_Environment.yml
      playbook_description: Ensures environment variables file exists and populated correctly
      state: updated

    Execute_Orchestrator:
      state: pristine
      playbook_name: Execute Orchestrator
      playbook_description: |
        Triggers the Meta Orchestrator system to apply configurations
        defined in the specification files. The other versions can be
        referenced by adding
        '-e meta_orchestrator_specifications_version=<version>'.
      playbook_path: Execute_Orchestrator.yml
      metadata:
        auto_generated: true
        pre_run_playbooks:
          - Setup_Environment.yml
      playbook_content:
        - play_id: Execute Orchestrator
          <<: *default_params
          tasks:
            - name: Execute Orchestratation of All Specifications
              trigger_role:
                <<: *orchestration_role
                scope: all

# tests/integration/meta_components_bootstrap.yml
---
- name: Set bootstrap facts
  connection: local
  hosts: localhost
  gather_facts: true
  tags:
    - always
  vars_files:
    - ../../vars/environment.yml
  vars:
    version: "0.8.0"
    bootstrap_destination_directory: "/tmp/orchestration_architect/{{ version }}/tests/integration_environment"
    bootstrap_source_directory: "{{ base_path }}/fixtures/{{ version }}"
    embed_template_fragment_script_path: "{{ bootstrap_destination_directory }}/plugins/scripts/embed_template_fragment.sh"
    specifications_path: "{{ bootstrap_destination_directory }}/vars/specifications/{{ version }}"
    roles_specifications_path: "{{ specifications_path }}/roles.yml"
    templates_specifications_path: "{{ specifications_path }}/templates.yml"
    relative_paths:
      meta_role_path: "roles/meta_role"
      meta_role_templates_path: "roles/meta_role/templates"
      meta_role_fragments_path: "roles/meta_role/templates/fragments"
    meta_role_path: "{{ bootstrap_destination_directory }}/{{ relative_paths.meta_role_path }}"
    meta_role_templates_path: "{{ bootstrap_destination_directory }}/{{ relative_paths.meta_role_templates_path }}"
    meta_role_fragments_path: "{{ bootstrap_destination_directory }}/{{ relative_paths.meta_role_fragments_path }}"
    meta_template_path: "{{ bootstrap_destination_directory }}/roles/meta_template"
    meta_template_templates_path: "{{ meta_template_path }}/templates"
  tasks:
    - name: Set playbook facts
      ansible.builtin.set_fact:
        version: "0.8.0"
        scripts_paths:
          embed_template_fragment: "{{ embed_template_fragment_script_path }}"
        bootstrap_destination_directory: "{{ bootstrap_destination_directory }}"
        bootstrap_source_directory: "{{ bootstrap_source_directory }}"
        specifications_path: "{{ specifications_path }}"
        roles_specifications_path: "{{ roles_specifications_path }}"
        templates_specifications_path: "{{ templates_specifications_path }}"
        relative_paths: "{{ relative_paths }}"
        meta_role_path: "{{ meta_role_path }}"
        meta_role_templates_path: "{{ meta_role_templates_path }}"
        meta_role_fragments_path: "{{ meta_role_fragments_path }}"
        meta_template_path: "{{ meta_template_path }}"
        meta_template_templates_path: "{{ meta_template_templates_path }}"

# (@process=Setup_Bootstrap_Destistination,PROJECT=OA-META)) 
- name: Setup Bootstrap Destination 
  connection: local
  hosts: localhost
  tags:
    - clean
  gather_facts: false
  pre_tasks:
    - name: Remove bootstrap destination directory
      ansible.builtin.file:
        state: absent
        path: "{{ bootstrap_destination_directory }}"
  tasks:
    - name: Create bootstrap destination directory
      ansible.builtin.file:
        state: directory
        path: "{{ bootstrap_destination_directory }}"
        mode: "0660"
    - name: Copy source bootstrap directory to destination directory
      ansible.builtin.synchronize:
        src: "{{ bootstrap_source_directory }}/"
        dest: "{{ bootstrap_destination_directory }}"
        recursive: true
    - name: Remove existing base.yml.j2.skel
      ansible.builtin.file:
        path: "{{ meta_role_templates_path }}/tasks/base.yml.j2.skel"
        state: absent
    - name: Remove existing main.yml.j2
      ansible.builtin.file:
        path: "{{ meta_role_templates_path }}/tasks/main.yml.j2"
        state: absent

- name: Load Specifications
  hosts: localhost
  connection: local
  tags:
    - always
  tasks:
    - name: Set specifications object
      ansible.builtin.set_fact:
        specifications:
          templates: {}
          roles: {}

    - name: Load specifications
      ansible.builtin.include_vars:
        file: "{{ item }}"
      loop:
        - "{{ roles_specifications_path }}"
        - "{{ templates_specifications_path }}"
    - name: Ensure roles specifications loaded
      ansible.builtin.assert:
        that:
          - roles_specifications.Meta is defined
          - roles_specifications.Base is defined
        fail_msg: "Unable to load roles_specifications"
        success_msg: "Accessed roles specifications file"

    - name: Apply 'Meta' role collection to 'Base' role (role specifications)
      vars: 
        specification_filter:
          type: "roles_specifications:collection_specifications"
          values: ['Meta']
      block:
        - name: Get role specifications from collections
          ansible.builtin.set_fact:
            roles_specifications_by_collection: "{{ lookup('template', meta_template_templates_path + '/specifications_lib.j2') | from_yaml }}"

        #  - debug:
        #      var: roles_specifications_by_collection

        - name: Process roles specifications
          loop: "{{ roles_specifications_by_collection }}"
          loop_control:
            loop_var: item
          vars:
            _roles_metadata: "{{ roles_specifications.metadata | combine({'version': version}, recursive=True) }}"
            _collection_id: "{{ item.collection_id }}"
            _role_id: "{{ item.role_id }}"
            _base_spec: "{{ item.base_spec }}"
            _role_spec: "{{ item.role_spec }}"
            _merged_spec: "{{ _base_spec | combine(_role_spec , recursive=true, list_merge='append_rp') }}"
            _specification_delta:
              roles: "{{ {
                  _collection_id: { _role_id: _merged_spec }
                } }}"
          ansible.builtin.set_fact: 
            specifications:
              roles: "{{ specifications.roles | default(roles_specifications) | combine(_specification_delta.roles, recursive=True, list_merge='append_rp') | combine({ 'metadata': (_roles_metadata), 'Base': roles_specifications.Base }, recursive=True) }}"

    # - name: Show roles specifications
    #   debug:
    #     var: specifications.roles
    - name: Ensure meta_role contains base components
      ansible.builtin.assert:
        that:
          - "'roles' in specifications"
          - "'Meta' in specifications.roles"
          - "'meta_role' in specifications.roles.Meta"
          - "'directories' in specifications.roles.Meta.meta_role"
        fail_msg: "Failed to merge meta_role role specification with Base"
        success_msg: "Meta collection merged successfully with Base role specification"

    ## Build Template Specification - Gets stuck here
    # if i specify a tag or skip clean
    - name: Enrich Template Specifications with Skeleton and Fragment Logic
      vars:        
        combined_template_fragments: "{{ templates_specifications.Base.template_fragments | combine(templates_specifications.Roles.template_fragments,recursive=true,list_merge='append_rp') }}" 
        roles_templates_specifications: "{{
          { 'Roles': (
            templates_specifications.Roles | combine({
              'template_fragments': combined_template_fragments
            }, recursive=true)) 
          }
            }}"
        base_skeleton: "{{ templates_specifications.Base.skeleton_specification }}"
        base_fragments: "{{ templates_specifications.Base.template_fragments }}"
        role_templates_skeleton_delta: "{{ roles_templates_specifications.Roles.templates
          | dict2items
          | rejectattr('value.skeleton_specification', 'defined')
          | map('combine',
            { 'value':
              {
                'skeleton_specification': templates_specifications.Base.skeleton_specification
              }
            }
          ) | items2dict }}"
        enriched_templates_specifications: "{{
          roles_templates_specifications
          | combine({
            'Roles': {
              'fields_map': templates_specifications.Base.fields,
              'templates': (roles_templates_specifications.Roles.templates | combine(role_templates_skeleton_delta))
            }
          }
          , recursive=True, list_merge='append_rp') }}"
      ansible.builtin.set_fact:
        specifications: "{{
          specifications | combine({
          'templates': enriched_templates_specifications
      }, recursive=true) }}"
    - name: Show templates specifications
      ansible.builtin.debug:
        var: specifications.templates

- name: Bootstrap meta role task
  connection: local
  hosts: localhost
  gather_facts: true
  tasks:
    - name: Generate missing skeletons
      vars:
        role_template_items: "{{ specifications.templates.Roles.templates | dict2items(key_name='template_id', value_name='specification') }}"
      block:
        - name: Check if skeleton file exists
          ansible.builtin.stat:
            path: "{{ meta_role_templates_path }}/{{ template_item.specification.skeleton_path }}"
          register: skeleton_stat
          loop: "{{ role_template_items }}"
          loop_control:
            loop_var: template_item
            label: "{{ template_item.template_id }},{{ template_item.specification.skeleton_path }}"
        - name: Debug missing keys
          vars:
            missing_skeletons_template_ids: "{{ skeleton_stat.results | selectattr('stat.exists', 'equalto', false) | map(attribute='template_item.template_id') | list }}"
          ansible.builtin.debug:
            msg: "{{ missing_skeletons_template_ids }}"

        - name: Generate missing skeleton files
          vars:
            missing_skeletons_template_ids: "{{ skeleton_stat.results | selectattr('stat.exists', 'equalto', false) | map(attribute='template_item.template_id') | list }}"
          block:
            - name: Generate skeleton
              vars:
                meta_role_templates_specification: "{{ specifications.templates.Roles }}"
                template_specification: "{{ meta_role_templates_specification.templates[template_id] }}"
                skeleton_metadata:
                  file_location: '{{ relative_paths.meta_role_templates_path }}/{{ template_specification.skeleton_path }}'
                metadata:
                  version: '{{ version }}'
                fields_map: "{{ specifications.templates.Roles.fields_map }}"
              ansible.builtin.template:
                src: "{{ meta_template_templates_path }}/skeleton.j2"
                dest: "{{ meta_role_templates_path }}/{{ template_specification.skeleton_path }}"
                mode: "0660"
              loop: "{{ missing_skeletons_template_ids }}"
              loop_control:
                loop_var: template_id
        - name: Build template for each specified template missing
          block:
            - name: Check if template file exists
              ansible.builtin.stat:
                path: "{{ template_item.specification.path }}"
              register: template_file_stat
              loop: "{{ specifications.templates.Roles.templates | dict2items(key_name='template_id',value_name='specification') }}"
              loop_control:
                loop_var: template_item
 
            - name: Embed template fragments from skeleton if not exists
              vars:
                # list of missing template_ids
                missing_templates_ids: "{{ template_file_stat.results | selectattr('stat.exists', 'equalto', false) | map(attribute='template_item.template_id') | list }}"
                # list of template specifications
                # [{ path: ..., skeleton_path: ...,
                # skeleton_specification: ... }, {...}, ...]
                missing_templates: "{{ missing_templates_ids | map('extract',specifications.templates.Roles.templates) }}"
                # list of skeleton specifications
                # [{ <REGION_A>: [<FRAGMENT_A_1, FRAGMENT_A_n],
                #   <REGION_B>: [...]},...]
                missing_skeleton_specification: "{{ missing_templates | map(attribute='skeleton_specification') | map('dict2items',key_name='region', value_name='fragment_list') }}"
              block:
                - name: Initialise templates_generation_object
                  ansible.builtin.set_fact:
                    fragments_and_regions_by_template: {}
                

                - name: Add templates fragment_region_pairs
                  vars:
                    template_specification: "{{ specifications.templates.Roles.templates[template_id] }}"
                    specification_filter:
                      type: 'specifications.templates:fragments_from_templates'

                  ansible.builtin.set_fact:
                    fragments_and_regions_by_template: "{{
                      fragments_and_regions_by_template | combine({
                        template_id: (
                          lookup('template',
                            meta_template_templates_path + '/specifications_lib.j2') | from_yaml)
                    }, recursive=true, list_merge='prepend_rp') }}"
                  loop: "{{ missing_templates_ids }}"
                  loop_control:
                    loop_var: template_id
                    extended: true
                - name: Embed fragments pairs
                  vars:
                    templates_path: "{{ bootstrap_destination_directory }}/{{ specifications.templates.Roles.templates_path }}"
                    fragments_path: "{{ bootstrap_destination_directory }}/{{ specifications.templates.Roles.fragments_path }}"

                    script_path: "{{ scripts_paths.embed_template_fragment}}"
                  block:
                    - name: Copy over skeleton to templates
                      vars:
                        template_specification: "{{ specifications.templates.Roles.templates[template_id] }}"
                        source: "{{ templates_path }}/{{ template_specification.skeleton_path }}"
                        destination: "{{ templates_path }}/{{ template_specification.path }}"
                      ansible.builtin.copy:
                        src: "{{ source }}"
                        dest: "{{ destination }}"
                        mode: "0660"

                      loop: "{{ fragments_and_regions_by_template.keys() }}"
                      loop_control:
                        loop_var: template_id

                    - name: Remove skeleton header
                      vars:
                        template_specification: "{{ specifications.templates.Roles.templates[item.1] }}"
                        destination: "{{ templates_path }}/{{ template_specification.path }}"
                      ansible.builtin.lineinfile:
                        path: "{{ destination }}"
                        regex: "{{ '# ' ~ item.0 }}:"
                        state: absent
                      loop: "{{ ['file','version'] | product(fragments_and_regions_by_template.keys() | list) }}"
                      loop_control:
                        loop_var: item

                    - name: Embed fragments
                      vars:
                        fragment_location: "{{ fragments_path }}/{{ specifications.templates.Roles.template_fragments[fragment_item.fragment_id].path }}"
                        template_location: "{{ templates_path }}/{{ specifications.templates.Roles.templates[fragment_item.template_id].path }}"
                      ansible.builtin.command: >
                          {{ script_path }}
                          {{ fragment_location }}
                          {{ template_location }}
                          {{ fragment_item.fragment_id }}
                          {{ '--region=' ~ fragment_item.region }}

                      loop: "{{ fragments_and_regions_by_template.values() | flatten }}"
                      loop_control:
                        loop_var: fragment_item

                    - name: Build inject fragment variable dictionary
                      vars:
                        template_specification: "{{ specifications.templates.Roles.templates[template_id] }}"
                        fragment_vars:
                          generation_timestamp: "{{ ansible_date_time.iso8601 }}"
                          version: "{{ version }}"
                          path: "{{ template_specification.path }}"
                          skeleton_path: "{{ template_specification.skeleton_path }}"
                      ansible.builtin.set_fact:
                        fragment_vars_by_template: "{{ (fragment_vars_by_template | default([]) + ([template_id] | product(fragment_vars | dict2items(key_name='var_name', value_name='var_value')))
                        
                        ) }}"
                        
                      loop: "{{ missing_templates_ids }}"
                      loop_control:
                        loop_var: template_id

                    - name: Inject fragment variables
                      vars:
                        template_specification: "{{ specifications.templates.Roles.templates[item[0]] }}"
                        var_name: "{{ item[1].var_name }}"
                        var_value: "{{ item[1].var_value }}"
                      ansible.builtin.replace:
                        path: "{{ bootstrap_destination_directory }}/{{ specifications.templates.Roles.templates_path }}/{{ template_specification.path }}"
                        regexp: "{{ '{{ fragment_vars.' ~ var_name ~ ' }}' }}"
                        replace: "{{ var_value }}"

                      loop: "{{ fragment_vars_by_template }}"


- name: Check ansible meta_role is operational
  connection: local
  hosts: localhost
  gather_facts: true
  tags:
    - meta_role
  vars:
    base_path: "{{ bootstrap_destination_directory }}"
    roles_path: "{{ base_path }}/roles"

  tasks:
    - name: Generate meta_role from specification
      vars:
        role_specification: "{{ specifications.roles.Meta.meta_role }}"
        directory_mode: "0770"
        file_mode: "0660"
      block:
        - debug:
            var: role_specification
        - name: Create role directories
          loop: "{{ role_specification.directories }}"
          loop_control:
            loop_var: directory
          ansible.builtin.file:
            state: directory
            path: "{{ [base_path, role_specification.role_path, directory.path] | path_join }}"
            mode: "{{ directory_mode }}"

        - name: Update and render template files as specified or if missing
          loop: "{{ role_specification.files }}"
          loop_control:
            loop_var: file
          vars:
            metadata: "{{ specifications.roles.metadata }}"
            specification: "{{ role_specification }}"
          ansible.builtin.template:
            src: "{{ [base_path, role_specification.role_path, 'templates',  file.template] | path_join }}"
            dest: "{{ [base_path, role_specification.role_path, file.path] | path_join }}"
            mode: "{{ file.mode | default(file_mode) }}"
            force: '{{ file.state is defined and file.state == "pristine" }}'
          when: file.template is defined
    - name: Check meta_role runs
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_role"
    - name: Check present task updates tasks/present.yml to latest version (specification set to updated)
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_role"
      vars:
        meta_role_state: present
        meta_role_specification: "{{ specifications.roles.Meta.meta_role }}"
        meta_role_metadata: "{{ specifications.roles.metadata }}"
        base_path: "{{ bootstrap_destination_directory }}"

    - name: Read content of present.yml
      ansible.builtin.slurp:
        src: "{{ meta_role_path }}/tasks/present.yml"
      register: present_yml_content
    - name: Decode content of present.yml
      ansible.builtin.set_fact:
        present_yml_decoded: "{{ present_yml_content['content'] | b64decode }}"
    - name: Assert that present.yml contains specific version string
      ansible.builtin.assert:
        that:
          - "'# version: 0.8.0' in present_yml_decoded"
          - "'Ensure the presence' in present_yml_decoded"

        fail_msg: "present.yml does not contain the expected version string or the first task"
        success_msg: "present.yml contains the expected version string"

- name: Validate meta_role can create roles (creates meta_orchestrator)
  connection: local
  hosts: localhost
  gather_facts: true
  tags:
    - meta_role
  vars:
    base_path: "{{ bootstrap_destination_directory }}"
    roles_path: "{{ bootstrap_destination_directory }}/roles"
    meta_role_specification: "{{ specifications.roles.Base | combine(specifications.roles.Meta.meta_orchestrator, recursive=True, list_merge='append_rp') }}"
    meta_role_metadata: "{{ specifications.roles.metadata }}"
    meta_role_state: present
  tasks:
    - name: Show specifications
      debug: 
        var: base_path
    - name: Generate meta_orchestrator using meta_role
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_role"
    - name: Assert meta_orchestrator runs
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_orchestrator"

- name: Validate meta_orchestrator can create roles (creates meta_template via schema)
  connection: local
  hosts: localhost
  gather_facts: true
  tags:
    - meta_role
    - meta_template
    - meta_orchestrator
  vars:
    base_path: "{{ bootstrap_destination_directory }}"
    roles_path: "{{ base_path }}/roles"
  pre_tasks:
    - name: Sync present.yml from meta_orchestrator
      copy:
        src: "../fixtures/{{ version }}/roles/meta_orchestrator/tasks/present.yml"
        dest: "{{ bootstrap_destination_directory }}/roles/meta_orchestrator/tasks/present.yml"
        mode: "0660"
  tasks:
    - name: Generate all roles (including meta_template and meta_playbook)
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_orchestrator"
      vars:
        meta_orchestrator_specifications_path: "{{ specifications_path }}"
        meta_orchestrator_state: "present"
        meta_orchestrator_scope: "schema"
        meta_orchestrator_operations:
          - process_roles
        meta_orchestrator_schema:
          roles:
            Meta:
              meta_template: {}
        base_path: "{{ bootstrap_destination_directory }}"
    - name: Assert meta_template runs
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_template"
      # scope this to process config, templates, roles
      # through schema,

# UP TO HERE, need to ensure that the specifications for each role is added. Validate that templates is present
# If templates is not defined (i.e. when generating meta_playbook before i specified the templates, it should generate the fragments if it is included
- name: Validate meta_template can update skeletons and fragments (creates meta_template, meta_playbook)
  connection: local
  hosts: localhost
  gather_facts: true
  tags:
    - meta_role
    - meta_template
  vars:
    base_path: "{{ bootstrap_destination_directory }}"
    roles_path: "{{ base_path }}/roles"
  tasks:
    - name: Generate meta_template and meta_playbook
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_orchestrator"
      vars:
        meta_orchestrator_specifications_path: "{{ specifications_path }}"
        meta_orchestrator_operations:
          - process_templates
          - process_roles
        base_path: "{{ bootstrap_destination_directory }}"
    - name: Assert meta_template can generate meta_playbook skeleton and templates
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_orchestrator"
      vars:
        base_path: "{{ bootstrap_destination_directory }}"
        meta_orchestrator_state: present
        meta_orchestrator_scope: schema
        meta_orchestrator_specifications_path: "{{ specifications_path }}"
        meta_orchestrator_specifications_version: "0.8.0"
        meta_orchestrator_schema:
          roles:
            Meta:
              meta_playbook: {}
          templates:
            Roles:
              meta_playbook: {}
            Playbooks:
              base_playbook: {}
              meta_playbook: {}

    # Check skeletons
    #   base.yml.j2.skel
    #   meta.yml.j2.skel
    # Add the template spec for any templates
    #   meta.yml.j2
    #   base.yml.j2
    #   test.yml.j2
    # Copy fragments to fixtures in new format
    #   10_templates_vars -> 00_template_file_header?, 10_template_vars
    # Checkregions
    #   15_common_template_macros.j2
    #   30_managed_block_before_plybook -> 30_managed_block_before_content
    - name: Assert that meta playbook runs
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_playbook"
    # Should just run info
    - name: Assert the Meta playbook runs from orchestrator
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_orchestrator"
      vars:
        base_path: "{{ bootstrap_destination_directory }}"
        meta_orchestrator_state: info
        meta_orchestrator_scope: all
        meta_orchestrator_operations: ['process_playbooks']
    - name: Show specification
      debug:
        var: specifications_path
    - name: Assert the Meta playbook generates a runnable playbook
      ansible.builtin.include_role:
        name: "{{ roles_path }}/meta_orchestrator"
      vars:
        base_path: "{{ bootstrap_destination_directory }}"
        meta_orchestrator_state: present
        meta_orchestrator_scope: all
        meta_orchestrator_operations: ['process_playbooks']
        meta_orchestrator_specifications_path: "{{ specifications_path }}"
        meta_orchestrator_specifications_version: "0.8.0"
    - name: TODO
      debug:
        msg: "Specification should create a playbook in the Meta collection, which will pass a test specification to meta_role which will run it, with version 0.9.0 will be part of meta_orchestrator, as version 0.9.0 should be able to migrate from 0.8.0"
    # Version 0.9.0 requirements
    # TODO Fix unit tests
    # Use meta_playbook 00_template_file_header.j2
    #   as base for template for template file headers
    # TODO Document pairing fixtures, integration bootstrap test to generate new version.
    # TODO Remove test fixtures meta_role/tasks/present.yml.new
    # TODO Implement Skeleton Update Logic
    #      Make next integration bootstrap version test
    #      be compatible to remove meta_templates/specifications_lib.j2
    # TODO Organise the integration bootstrap test
    #      so it is structured to represent
    #      moving between limit and colimit
    # TODO Make migration playbook (autogenerated)
    #      from specifications, that can be edited
    #      to hold the implementation needed to
    #      achieve the next step, and the playbook will
    #      auto play the migration in work directory
    #      with the individually included playbook
    #      representing the changes to allow a
    #      limit->colimit step work.
    #      Migratation Playbook <- [Setup Fixtures playbook, Generate integration bootstrap test, Setup Facts and paths in generated test -> tests can be run and the test environment runs, load specifications -> confirm specifications raw specifications available in file, the specification is enriched -> injected into integration test and/or base task (do i use the previous version task file, or do i build the task file from scratch and put it so that it can generate the role).
    # TODO Write playbook to copy fixtures version,
    #      and instantiate next version 0.8.1
    #      so that the system can regenerate itself.
    # TODO Document new path pattern for work directory
    #     /tmp/orchestration_architect/<version>/tests/{integration,unit}
    #     integration := { <environment>,work} 
    #     unit := { {<unit_test_name (e.g. meta_role_present_task>/{work, otherfiles }
    #
    #   move fixtures to {base}/fixtures/{version}/
    # make fragments/template_file_header.j2 uniform 
    # between playbook, roles, by adding
    # 00_template_file_header.j2 to meta_template templates
    # and later make template_vars fragment auto wire
    # make it so each template collection holds the
    # name of the component being generated, for 
    # now just make the template and fragments paths
    # be able to generated using fields
    #
    # explore the generation of using fields to hold
    #   node key paths (or generate them), to map
    #   output from caller to input to callee.
    #
    # vars from the meta component to vars used in the 
    # templates
    #
    # next version, carefully document all steps
    # taken to achieve it, so it can be integrated
    # back in 


